<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>图相关的基本算法 | zzys</title><meta name="description" content="zzys的个人博客">
    <link rel="preload" href="/assets/style-ec18e87d.css" as="style"><link rel="stylesheet" href="/assets/style-ec18e87d.css">
    <link rel="modulepreload" href="/assets/app-8f4b6e6f.js"><link rel="modulepreload" href="/assets/图相关的基本算法.html-1e388343.js"><link rel="modulepreload" href="/assets/图相关的基本算法.html-3374d688.js"><link rel="prefetch" href="/assets/About.html-905bcaa6.js" as="script"><link rel="prefetch" href="/assets/index.html-1124f69b.js" as="script"><link rel="prefetch" href="/assets/index.html-b5ca648f.js" as="script"><link rel="prefetch" href="/assets/index.html-bec769cf.js" as="script"><link rel="prefetch" href="/assets/all.html-7d7fbf0a.js" as="script"><link rel="prefetch" href="/assets/index.html-ed5da3db.js" as="script"><link rel="prefetch" href="/assets/markdown.html-da1a35cd.js" as="script"><link rel="prefetch" href="/assets/mermaid使用.html-3fbe0211.js" as="script"><link rel="prefetch" href="/assets/ai-sundry.html-f2123f7b.js" as="script"><link rel="prefetch" href="/assets/DFS、BFS.html-0152ce7c.js" as="script"><link rel="prefetch" href="/assets/KMP、Trie.html-dc92ba21.js" as="script"><link rel="prefetch" href="/assets/二分问题.html-aac3900c.js" as="script"><link rel="prefetch" href="/assets/位运算、离散化、区间合并.html-95650150.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-13bb620c.js" as="script"><link rel="prefetch" href="/assets/双指针.html-93090f76.js" as="script"><link rel="prefetch" href="/assets/堆、哈希.html-241abe1d.js" as="script"><link rel="prefetch" href="/assets/差分.html-b7e4cfd1.js" as="script"><link rel="prefetch" href="/assets/COW-写时复制.html-607e38a6.js" as="script"><link rel="prefetch" href="/assets/snowflakeid.html-db9b4359.js" as="script"><link rel="prefetch" href="/assets/两阶段提交.html-f1cd283a.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-dbe6fb5f.js" as="script"><link rel="prefetch" href="/assets/幂等.html-52411ecf.js" as="script"><link rel="prefetch" href="/assets/秒杀场景.html-632fc29c.js" as="script"><link rel="prefetch" href="/assets/限流.html-140ddd4d.js" as="script"><link rel="prefetch" href="/assets/Golang-万声音乐-实习-23-12-27.html-28b6bfe4.js" as="script"><link rel="prefetch" href="/assets/Golang-百度-实习-23-12-11.html-049f9e2c.js" as="script"><link rel="prefetch" href="/assets/Java-喜马拉雅-实习-23-8-21.html-065a1c40.js" as="script"><link rel="prefetch" href="/assets/Java-数新网络-实习-23-12-07.html-cacab6ef.js" as="script"><link rel="prefetch" href="/assets/go.html-fd549940.js" as="script"><link rel="prefetch" href="/assets/java.html-eb00cff3.js" as="script"><link rel="prefetch" href="/assets/computer-summary.html-fa14ac34.js" as="script"><link rel="prefetch" href="/assets/system-bus.html-5f096e12.js" as="script"><link rel="prefetch" href="/assets/csapp-信息的表示和处理.html-29b9797b.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(1).html-bb86f81c.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(2).html-6a02070c.js" as="script"><link rel="prefetch" href="/assets/network-ttd-application.html-cd54765f.js" as="script"><link rel="prefetch" href="/assets/network-ttd-summary.html-b0810214.js" as="script"><link rel="prefetch" href="/assets/ostep-concurrency.html-9f5a4e02.js" as="script"><link rel="prefetch" href="/assets/ostep-persistence.html-67845dc5.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-cpu.html-6c7c365c.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-memory.html-6d736047.js" as="script"><link rel="prefetch" href="/assets/index.html-2bac24fc.js" as="script"><link rel="prefetch" href="/assets/数据库表设计.html-155d4faa.js" as="script"><link rel="prefetch" href="/assets/测试.html-b1b1df80.js" as="script"><link rel="prefetch" href="/assets/组件开发.html-3811c884.js" as="script"><link rel="prefetch" href="/assets/项目准备.html-19019ac3.js" as="script"><link rel="prefetch" href="/assets/snmp-Java.html-1d5933c4.js" as="script"><link rel="prefetch" href="/assets/snmp压力测试.html-43e454d9.js" as="script"><link rel="prefetch" href="/assets/AOP.html-08519e3c.js" as="script"><link rel="prefetch" href="/assets/IOC.html-bbb032df.js" as="script"><link rel="prefetch" href="/assets/JdbcTemplate-Transaction.html-45ebad5a.js" as="script"><link rel="prefetch" href="/assets/MVC.html-217b44a6.js" as="script"><link rel="prefetch" href="/assets/verilog.html-a16c05b0.js" as="script"><link rel="prefetch" href="/assets/关于提问.html-a1d3cc68.js" as="script"><link rel="prefetch" href="/assets/DP.html-40b096d3.js" as="script"><link rel="prefetch" href="/assets/线性DP.html-6abac9c1.js" as="script"><link rel="prefetch" href="/assets/背包问题.html-f78447ad.js" as="script"><link rel="prefetch" href="/assets/index.html-0e6f93b0.js" as="script"><link rel="prefetch" href="/assets/归并排序.html-1acadf46.js" as="script"><link rel="prefetch" href="/assets/快速排序.html-09eb791d.js" as="script"><link rel="prefetch" href="/assets/单链表和双链表的数组实现.html-bf919e6d.js" as="script"><link rel="prefetch" href="/assets/并查集.html-66337019.js" as="script"><link rel="prefetch" href="/assets/栈和队列.html-77c4e30b.js" as="script"><link rel="prefetch" href="/assets/树状数组和线段树.html-5a392d61.js" as="script"><link rel="prefetch" href="/assets/树、图的存储和遍历.html-7dfcf155.js" as="script"><link rel="prefetch" href="/assets/DesignPattern.html-d1e8d094.js" as="script"><link rel="prefetch" href="/assets/builder.html-30f560af.js" as="script"><link rel="prefetch" href="/assets/chain.html-ed1b2acb.js" as="script"><link rel="prefetch" href="/assets/strategy.html-1d5899e0.js" as="script"><link rel="prefetch" href="/assets/golang-plugin.html-47c8f36c.js" as="script"><link rel="prefetch" href="/assets/golang基础入门.html-afaf7ee0.js" as="script"><link rel="prefetch" href="/assets/index.html-d0dd1a10.js" as="script"><link rel="prefetch" href="/assets/SPI.html-8a3365b2.js" as="script"><link rel="prefetch" href="/assets/jvm.html-e270154b.js" as="script"><link rel="prefetch" href="/assets/ruoyi-vue启动配置.html-90198d7b.js" as="script"><link rel="prefetch" href="/assets/redis使用场景.html-34c00e53.js" as="script"><link rel="prefetch" href="/assets/redis持久化.html-bfc1cefc.js" as="script"><link rel="prefetch" href="/assets/springboot发布订阅机制.html-5175d1fa.js" as="script"><link rel="prefetch" href="/assets/动手写starter.html-c60b47b8.js" as="script"><link rel="prefetch" href="/assets/自定义spring-cloud-gateway-filter.html-d11e8c8b.js" as="script"><link rel="prefetch" href="/assets/非spring管理的类使用bean.html-9680c239.js" as="script"><link rel="prefetch" href="/assets/C编程杂记.html-186c382d.js" as="script"><link rel="prefetch" href="/assets/Makefile.html-e140ef4f.js" as="script"><link rel="prefetch" href="/assets/CPU缓存一致性.html-6c29ed13.js" as="script"><link rel="prefetch" href="/assets/risc-v.html-abe15f5f.js" as="script"><link rel="prefetch" href="/assets/汇编下的函数调用.html-38baefd4.js" as="script"><link rel="prefetch" href="/assets/IO多路复用.html-7987f38e.js" as="script"><link rel="prefetch" href="/assets/kernel-bypass.html-35f2b2e7.js" as="script"><link rel="prefetch" href="/assets/kernel-user-buffer.html-f51a977b.js" as="script"><link rel="prefetch" href="/assets/page-cache.html-295e685e.js" as="script"><link rel="prefetch" href="/assets/零拷贝.html-278a7ac9.js" as="script"><link rel="prefetch" href="/assets/InnoDB存储引擎.html-59c14a8e.js" as="script"><link rel="prefetch" href="/assets/事务.html-5febd507.js" as="script"><link rel="prefetch" href="/assets/索引.html-33cba37d.js" as="script"><link rel="prefetch" href="/assets/锁.html-4d1a821d.js" as="script"><link rel="prefetch" href="/assets/docker-sundry.html-ef4dc397.js" as="script"><link rel="prefetch" href="/assets/Backup-VMware.html-7c28803d.js" as="script"><link rel="prefetch" href="/assets/Frangipani.html-efd69a09.js" as="script"><link rel="prefetch" href="/assets/GFS.html-c0190339.js" as="script"><link rel="prefetch" href="/assets/Introduction-MapReduce.html-baff309c.js" as="script"><link rel="prefetch" href="/assets/index.html-f80c2489.js" as="script"><link rel="prefetch" href="/assets/Spanner.html-b14643bf.js" as="script"><link rel="prefetch" href="/assets/Zookeeper.html-70da7092.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-5b0c0d47.js" as="script"><link rel="prefetch" href="/assets/链式复制.html-89fe6b95.js" as="script"><link rel="prefetch" href="/assets/Angular基础入门.html-9caaa6fe.js" as="script"><link rel="prefetch" href="/assets/Angular环境配置和基础认知.html-64107121.js" as="script"><link rel="prefetch" href="/assets/ES6-01 let和const.html-ff066299.js" as="script"><link rel="prefetch" href="/assets/ES6-02 解构赋值.html-d71d95a8.js" as="script"><link rel="prefetch" href="/assets/ES6-03 class.html-a18531b4.js" as="script"><link rel="prefetch" href="/assets/ES6-04 ES6新增用法.html-44208019.js" as="script"><link rel="prefetch" href="/assets/ES6-05 Symbol.html-60bc338b.js" as="script"><link rel="prefetch" href="/assets/ES6-06 Module的导入和导出.html-b047a5c9.js" as="script"><link rel="prefetch" href="/assets/支付服务.html-a1d43d44.js" as="script"><link rel="prefetch" href="/assets/用户服务.html-f9de0dca.js" as="script"><link rel="prefetch" href="/assets/票务服务.html-8a828469.js" as="script"><link rel="prefetch" href="/assets/订单服务.html-a9509189.js" as="script"><link rel="prefetch" href="/assets/Redis.html-d7c24a25.js" as="script"><link rel="prefetch" href="/assets/RocketMq.html-a2e7cc56.js" as="script"><link rel="prefetch" href="/assets/最长系列.html-c61159b1.js" as="script"><link rel="prefetch" href="/assets/反转链表.html-3876e4db.js" as="script"><link rel="prefetch" href="/assets/合并链表.html-8448b95f.js" as="script"><link rel="prefetch" href="/assets/数的二次方根.html-015c62b1.js" as="script"><link rel="prefetch" href="/assets/组合.html-5d3bdc98.js" as="script"><link rel="prefetch" href="/assets/go-zero入门实践.html-3ac3732f.js" as="script"><link rel="prefetch" href="/assets/Basic.html-394238ab.js" as="script"><link rel="prefetch" href="/assets/Collction.html-8f5a4579.js" as="script"><link rel="prefetch" href="/assets/JDK动态代理.html-558bcf44.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal.html-56b3c13b.js" as="script"><link rel="prefetch" href="/assets/enum.html-a0d9e8a9.js" as="script"><link rel="prefetch" href="/assets/this与super.html-dfcab97c.js" as="script"><link rel="prefetch" href="/assets/方法调用.html-8663b59b.js" as="script"><link rel="prefetch" href="/assets/泛型.html-a3b1e955.js" as="script"><link rel="prefetch" href="/assets/juc.html-aca7fee8.js" as="script"><link rel="prefetch" href="/assets/快速消费线程池.html-b751f9c8.js" as="script"><link rel="prefetch" href="/assets/summary-question.html-7bbf36ce.js" as="script"><link rel="prefetch" href="/assets/ebpf杂记.html-6b8f85f7.js" as="script"><link rel="prefetch" href="/assets/404.html-5b1f7f3d.js" as="script"><link rel="prefetch" href="/assets/About.html-b131f5d1.js" as="script"><link rel="prefetch" href="/assets/index.html-b3d2ae0c.js" as="script"><link rel="prefetch" href="/assets/index.html-cb725545.js" as="script"><link rel="prefetch" href="/assets/index.html-3b7145c3.js" as="script"><link rel="prefetch" href="/assets/all.html-5a67f8d7.js" as="script"><link rel="prefetch" href="/assets/index.html-6c2367ab.js" as="script"><link rel="prefetch" href="/assets/markdown.html-53550368.js" as="script"><link rel="prefetch" href="/assets/mermaid使用.html-52a464f9.js" as="script"><link rel="prefetch" href="/assets/ai-sundry.html-f9e33189.js" as="script"><link rel="prefetch" href="/assets/DFS、BFS.html-ffd1375c.js" as="script"><link rel="prefetch" href="/assets/KMP、Trie.html-dd9787d0.js" as="script"><link rel="prefetch" href="/assets/二分问题.html-a7302499.js" as="script"><link rel="prefetch" href="/assets/位运算、离散化、区间合并.html-39635336.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-3a4bde77.js" as="script"><link rel="prefetch" href="/assets/双指针.html-81c25a45.js" as="script"><link rel="prefetch" href="/assets/堆、哈希.html-5526206a.js" as="script"><link rel="prefetch" href="/assets/差分.html-58ef4e8f.js" as="script"><link rel="prefetch" href="/assets/COW-写时复制.html-bc15876e.js" as="script"><link rel="prefetch" href="/assets/snowflakeid.html-a94163f7.js" as="script"><link rel="prefetch" href="/assets/两阶段提交.html-0d00b84a.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-b4467a6c.js" as="script"><link rel="prefetch" href="/assets/幂等.html-5c4f9462.js" as="script"><link rel="prefetch" href="/assets/秒杀场景.html-79d3b743.js" as="script"><link rel="prefetch" href="/assets/限流.html-be1f195c.js" as="script"><link rel="prefetch" href="/assets/Golang-万声音乐-实习-23-12-27.html-433dae8f.js" as="script"><link rel="prefetch" href="/assets/Golang-百度-实习-23-12-11.html-3a0aab1c.js" as="script"><link rel="prefetch" href="/assets/Java-喜马拉雅-实习-23-8-21.html-87472172.js" as="script"><link rel="prefetch" href="/assets/Java-数新网络-实习-23-12-07.html-d0645623.js" as="script"><link rel="prefetch" href="/assets/go.html-aec7e12b.js" as="script"><link rel="prefetch" href="/assets/java.html-a673a9c2.js" as="script"><link rel="prefetch" href="/assets/computer-summary.html-f77fff3c.js" as="script"><link rel="prefetch" href="/assets/system-bus.html-5ffe90b4.js" as="script"><link rel="prefetch" href="/assets/csapp-信息的表示和处理.html-ba6cd8e5.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(1).html-66297692.js" as="script"><link rel="prefetch" href="/assets/csapp-程序的机器级表示(2).html-52108bf9.js" as="script"><link rel="prefetch" href="/assets/network-ttd-application.html-73395fe7.js" as="script"><link rel="prefetch" href="/assets/network-ttd-summary.html-3cafe401.js" as="script"><link rel="prefetch" href="/assets/ostep-concurrency.html-6210ca21.js" as="script"><link rel="prefetch" href="/assets/ostep-persistence.html-63978404.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-cpu.html-93d2fb92.js" as="script"><link rel="prefetch" href="/assets/ostep-virtualization-memory.html-f5664b0c.js" as="script"><link rel="prefetch" href="/assets/index.html-b859a677.js" as="script"><link rel="prefetch" href="/assets/数据库表设计.html-b016d5a4.js" as="script"><link rel="prefetch" href="/assets/测试.html-4fd82fb0.js" as="script"><link rel="prefetch" href="/assets/组件开发.html-407c0e8a.js" as="script"><link rel="prefetch" href="/assets/项目准备.html-1440a8eb.js" as="script"><link rel="prefetch" href="/assets/snmp-Java.html-438d24da.js" as="script"><link rel="prefetch" href="/assets/snmp压力测试.html-c0072cd5.js" as="script"><link rel="prefetch" href="/assets/AOP.html-61eae8eb.js" as="script"><link rel="prefetch" href="/assets/IOC.html-af3e4007.js" as="script"><link rel="prefetch" href="/assets/JdbcTemplate-Transaction.html-cde541c4.js" as="script"><link rel="prefetch" href="/assets/MVC.html-2526d7a1.js" as="script"><link rel="prefetch" href="/assets/verilog.html-00872b45.js" as="script"><link rel="prefetch" href="/assets/关于提问.html-501f0d3e.js" as="script"><link rel="prefetch" href="/assets/DP.html-26b823ee.js" as="script"><link rel="prefetch" href="/assets/线性DP.html-b8f4e32b.js" as="script"><link rel="prefetch" href="/assets/背包问题.html-3e5a7537.js" as="script"><link rel="prefetch" href="/assets/index.html-ac9b5370.js" as="script"><link rel="prefetch" href="/assets/归并排序.html-02cd8fc8.js" as="script"><link rel="prefetch" href="/assets/快速排序.html-0441e2d1.js" as="script"><link rel="prefetch" href="/assets/单链表和双链表的数组实现.html-7bfca357.js" as="script"><link rel="prefetch" href="/assets/并查集.html-487e232c.js" as="script"><link rel="prefetch" href="/assets/栈和队列.html-c3a454ec.js" as="script"><link rel="prefetch" href="/assets/树状数组和线段树.html-a98b3a35.js" as="script"><link rel="prefetch" href="/assets/树、图的存储和遍历.html-ed6040ae.js" as="script"><link rel="prefetch" href="/assets/DesignPattern.html-2adbf26b.js" as="script"><link rel="prefetch" href="/assets/builder.html-6cefdc6b.js" as="script"><link rel="prefetch" href="/assets/chain.html-95268f88.js" as="script"><link rel="prefetch" href="/assets/strategy.html-a19c1b92.js" as="script"><link rel="prefetch" href="/assets/golang-plugin.html-ee9645a5.js" as="script"><link rel="prefetch" href="/assets/golang基础入门.html-f880f8f0.js" as="script"><link rel="prefetch" href="/assets/index.html-82285a2e.js" as="script"><link rel="prefetch" href="/assets/SPI.html-25115f8b.js" as="script"><link rel="prefetch" href="/assets/jvm.html-e267057c.js" as="script"><link rel="prefetch" href="/assets/ruoyi-vue启动配置.html-84e5b4ba.js" as="script"><link rel="prefetch" href="/assets/redis使用场景.html-3deaf655.js" as="script"><link rel="prefetch" href="/assets/redis持久化.html-54585191.js" as="script"><link rel="prefetch" href="/assets/springboot发布订阅机制.html-40a7147d.js" as="script"><link rel="prefetch" href="/assets/动手写starter.html-4d7b38e4.js" as="script"><link rel="prefetch" href="/assets/自定义spring-cloud-gateway-filter.html-44021e3e.js" as="script"><link rel="prefetch" href="/assets/非spring管理的类使用bean.html-0c0f5cd1.js" as="script"><link rel="prefetch" href="/assets/C编程杂记.html-66d9160c.js" as="script"><link rel="prefetch" href="/assets/Makefile.html-56c9378b.js" as="script"><link rel="prefetch" href="/assets/CPU缓存一致性.html-6c3dde10.js" as="script"><link rel="prefetch" href="/assets/risc-v.html-f09ea2da.js" as="script"><link rel="prefetch" href="/assets/汇编下的函数调用.html-a5e86473.js" as="script"><link rel="prefetch" href="/assets/IO多路复用.html-cf3a4831.js" as="script"><link rel="prefetch" href="/assets/kernel-bypass.html-84e5d7f0.js" as="script"><link rel="prefetch" href="/assets/kernel-user-buffer.html-3b2b83bd.js" as="script"><link rel="prefetch" href="/assets/page-cache.html-17a7292b.js" as="script"><link rel="prefetch" href="/assets/零拷贝.html-8a45b5b0.js" as="script"><link rel="prefetch" href="/assets/InnoDB存储引擎.html-3973cb01.js" as="script"><link rel="prefetch" href="/assets/事务.html-c8056470.js" as="script"><link rel="prefetch" href="/assets/索引.html-acf30c8b.js" as="script"><link rel="prefetch" href="/assets/锁.html-72334d8e.js" as="script"><link rel="prefetch" href="/assets/docker-sundry.html-e1533411.js" as="script"><link rel="prefetch" href="/assets/Backup-VMware.html-3dade26e.js" as="script"><link rel="prefetch" href="/assets/Frangipani.html-d22fab12.js" as="script"><link rel="prefetch" href="/assets/GFS.html-8c89f0c6.js" as="script"><link rel="prefetch" href="/assets/Introduction-MapReduce.html-e94f6ded.js" as="script"><link rel="prefetch" href="/assets/index.html-5b9c4a77.js" as="script"><link rel="prefetch" href="/assets/Spanner.html-2cba8d04.js" as="script"><link rel="prefetch" href="/assets/Zookeeper.html-e20bdb6a.js" as="script"><link rel="prefetch" href="/assets/分布式事务.html-d12c2d2d.js" as="script"><link rel="prefetch" href="/assets/链式复制.html-27dbd89b.js" as="script"><link rel="prefetch" href="/assets/Angular基础入门.html-a93614d8.js" as="script"><link rel="prefetch" href="/assets/Angular环境配置和基础认知.html-152d581f.js" as="script"><link rel="prefetch" href="/assets/ES6-01 let和const.html-cbd73f0c.js" as="script"><link rel="prefetch" href="/assets/ES6-02 解构赋值.html-44fa8c64.js" as="script"><link rel="prefetch" href="/assets/ES6-03 class.html-2be1cd84.js" as="script"><link rel="prefetch" href="/assets/ES6-04 ES6新增用法.html-6487f639.js" as="script"><link rel="prefetch" href="/assets/ES6-05 Symbol.html-6e9a14b1.js" as="script"><link rel="prefetch" href="/assets/ES6-06 Module的导入和导出.html-7ceaf3d7.js" as="script"><link rel="prefetch" href="/assets/支付服务.html-628c6bd8.js" as="script"><link rel="prefetch" href="/assets/用户服务.html-58029037.js" as="script"><link rel="prefetch" href="/assets/票务服务.html-9fcd049f.js" as="script"><link rel="prefetch" href="/assets/订单服务.html-7cacdb70.js" as="script"><link rel="prefetch" href="/assets/Redis.html-77ab897f.js" as="script"><link rel="prefetch" href="/assets/RocketMq.html-3c3eb80c.js" as="script"><link rel="prefetch" href="/assets/最长系列.html-8bfd7705.js" as="script"><link rel="prefetch" href="/assets/反转链表.html-8ae13a82.js" as="script"><link rel="prefetch" href="/assets/合并链表.html-d5a06a8c.js" as="script"><link rel="prefetch" href="/assets/数的二次方根.html-d320dd89.js" as="script"><link rel="prefetch" href="/assets/组合.html-145d562b.js" as="script"><link rel="prefetch" href="/assets/go-zero入门实践.html-9cf317bf.js" as="script"><link rel="prefetch" href="/assets/Basic.html-0ccc6969.js" as="script"><link rel="prefetch" href="/assets/Collction.html-e7ff46a8.js" as="script"><link rel="prefetch" href="/assets/JDK动态代理.html-5f1c0515.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal.html-f4341261.js" as="script"><link rel="prefetch" href="/assets/enum.html-17ec29cb.js" as="script"><link rel="prefetch" href="/assets/this与super.html-c49a7c37.js" as="script"><link rel="prefetch" href="/assets/方法调用.html-ab00bbd6.js" as="script"><link rel="prefetch" href="/assets/泛型.html-8442b56f.js" as="script"><link rel="prefetch" href="/assets/juc.html-0a46d6d0.js" as="script"><link rel="prefetch" href="/assets/快速消费线程池.html-8df6fc6b.js" as="script"><link rel="prefetch" href="/assets/summary-question.html-a17c79cf.js" as="script"><link rel="prefetch" href="/assets/ebpf杂记.html-4b5603b0.js" as="script"><link rel="prefetch" href="/assets/404.html-018f3952.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-33486bc2.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">zzys</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/interview/" class="" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><div class="navbar-item"><a href="/code/" class="router-link-active" aria-label="code"><!--[--><!--]--> code <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/YangZhang-dev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/interview/" class="" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><div class="navbar-item"><a href="/code/" class="router-link-active" aria-label="code"><!--[--><!--]--> code <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/YangZhang-dev" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">code <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">ai <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/ai/ai-sundry.html" class="sidebar-item" aria-label="ai-sundry"><!--[--><!--]--> ai-sundry <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item active collapsible">algorithm <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">dp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/dp/DP.html" class="sidebar-item" aria-label="DP问题"><!--[--><!--]--> DP问题 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/dp/%E7%BA%BF%E6%80%A7DP.html" class="sidebar-item" aria-label="线性DP"><!--[--><!--]--> 线性DP <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/dp/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="背包问题"><!--[--><!--]--> 背包问题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">leetcode <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">dp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/leetcode/dp/%E6%9C%80%E9%95%BF%E7%B3%BB%E5%88%97.html" class="sidebar-item" aria-label="最长系列"><!--[--><!--]--> 最长系列 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">link <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/leetcode/link/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html" class="sidebar-item" aria-label="反转链表"><!--[--><!--]--> 反转链表 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/leetcode/link/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8.html" class="sidebar-item" aria-label="合并链表"><!--[--><!--]--> 合并链表 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">二分 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/leetcode/%E4%BA%8C%E5%88%86/%E6%95%B0%E7%9A%84%E4%BA%8C%E6%AC%A1%E6%96%B9%E6%A0%B9.html" class="sidebar-item" aria-label="数的二次方根"><!--[--><!--]--> 数的二次方根 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">回溯 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/leetcode/%E5%9B%9E%E6%BA%AF/%E7%BB%84%E5%90%88.html" class="sidebar-item" aria-label="组合"><!--[--><!--]--> 组合 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">排序 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html" class="sidebar-item" aria-label="归并排序"><!--[--><!--]--> 归并排序 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" class="sidebar-item" aria-label="快速排序"><!--[--><!--]--> 快速排序 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">数据结构 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0.html" class="sidebar-item" aria-label="单链表和双链表的数组实现"><!--[--><!--]--> 单链表和双链表的数组实现 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86.html" class="sidebar-item" aria-label="并查集"><!--[--><!--]--> 并查集 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html" class="sidebar-item" aria-label="栈和队列"><!--[--><!--]--> 栈和队列 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91.html" class="sidebar-item" aria-label="树状数组和线段树"><!--[--><!--]--> 树状数组和线段树 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item active collapsible">树图 <span class="down arrow"></span></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="图相关的基本算法"><!--[--><!--]--> 图相关的基本算法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-单源最短路" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 单源最短路"><!--[--><!--]--> 1. 单源最短路 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-1-dijkstra算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 Dijkstra算法"><!--[--><!--]--> 1.1 Dijkstra算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-2-bellman-ford算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2  Bellman-Ford算法"><!--[--><!--]--> 1.2  Bellman-Ford算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-3-spfa算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 SPFA算法"><!--[--><!--]--> 1.3 SPFA算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_2-多源最短路" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 多源最短路"><!--[--><!--]--> 2. 多源最短路 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_2-1-floyd算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 Floyd算法"><!--[--><!--]--> 2.1 Floyd算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-prim-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. prim 算法"><!--[--><!--]--> 1. prim 算法 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-1-1-朴素版prim算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1.1 朴素版prim算法"><!--[--><!--]--> 1.1.1 朴素版prim算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-1-2-堆优化版prim算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1.2 堆优化版prim算法"><!--[--><!--]--> 1.1.2 堆优化版prim算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_2-kruskal-算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. Kruskal 算法"><!--[--><!--]--> 2. Kruskal 算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_1-染色法" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 染色法"><!--[--><!--]--> 1. 染色法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95.html#_2-匈牙利算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 匈牙利算法"><!--[--><!--]--> 2. 匈牙利算法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E6%A0%91%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86.html" class="sidebar-item" aria-label="树和图的存储及遍历"><!--[--><!--]--> 树和图的存储及遍历 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/algorithm/DFS%E3%80%81BFS.html" class="sidebar-item" aria-label="DFS、BFS"><!--[--><!--]--> DFS、BFS <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/KMP%E3%80%81Trie.html" class="sidebar-item" aria-label="KMP、Trie"><!--[--><!--]--> KMP、Trie <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98.html" class="sidebar-item" aria-label="二分"><!--[--><!--]--> 二分 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6.html" class="sidebar-item" aria-label="位运算、离散化、区间合并"><!--[--><!--]--> 位运算、离散化、区间合并 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%89%8D%E7%BC%80%E5%92%8C.html" class="sidebar-item" aria-label="前缀和"><!--[--><!--]--> 前缀和 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88.html" class="sidebar-item" aria-label="双指针"><!--[--><!--]--> 双指针 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%A0%86%E3%80%81%E5%93%88%E5%B8%8C.html" class="sidebar-item" aria-label="堆和哈希"><!--[--><!--]--> 堆和哈希 <!--[--><!--]--></a><!----></li><li><a href="/code/algorithm/%E5%B7%AE%E5%88%86.html" class="sidebar-item" aria-label="差分"><!--[--><!--]--> 差分 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">back <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">designpattern <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/designpattern/DesignPattern.html" class="sidebar-item" aria-label="设计模式"><!--[--><!--]--> 设计模式 <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/builder.html" class="sidebar-item" aria-label="builder"><!--[--><!--]--> builder <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/chain.html" class="sidebar-item" aria-label="builder"><!--[--><!--]--> builder <!--[--><!--]--></a><!----></li><li><a href="/code/back/designpattern/strategy.html" class="sidebar-item" aria-label="strategy"><!--[--><!--]--> strategy <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">go <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">go-zero <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/go/go-zero/go-zero%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5.html" class="sidebar-item" aria-label="go-zero的入门实践"><!--[--><!--]--> go-zero的入门实践 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/back/go/golang-plugin.html" class="sidebar-item" aria-label="golang-plugin"><!--[--><!--]--> golang-plugin <!--[--><!--]--></a><!----></li><li><a href="/code/back/go/golang%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" class="sidebar-item" aria-label="golang基础入门"><!--[--><!--]--> golang基础入门 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">mq <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">rocketmq <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/mq/rocketmq/summary-question.html" class="sidebar-item" aria-label="summary-question"><!--[--><!--]--> summary-question <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">redis <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/redis/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="redis使用场景"><!--[--><!--]--> redis使用场景 <!--[--><!--]--></a><!----></li><li><a href="/code/back/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96.html" class="sidebar-item" aria-label="redis持久化"><!--[--><!--]--> redis持久化 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">spring <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/back/spring/%E5%8A%A8%E6%89%8B%E5%86%99starter.html" class="sidebar-item" aria-label="动手写starter"><!--[--><!--]--> 动手写starter <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/%E9%9D%9Espring%E7%AE%A1%E7%90%86%E7%9A%84%E7%B1%BB%E4%BD%BF%E7%94%A8bean.html" class="sidebar-item" aria-label="非spring管理的类使用bean"><!--[--><!--]--> 非spring管理的类使用bean <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/%E8%87%AA%E5%AE%9A%E4%B9%89spring-cloud-gateway-filter.html" class="sidebar-item" aria-label="自定义spring-cloud-gateway-filter"><!--[--><!--]--> 自定义spring-cloud-gateway-filter <!--[--><!--]--></a><!----></li><li><a href="/code/back/spring/springboot%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6.html" class="sidebar-item" aria-label="springboot发布订阅机制"><!--[--><!--]--> springboot发布订阅机制 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">basic <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">C <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/C/C%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0.html" class="sidebar-item" aria-label="C编程杂记"><!--[--><!--]--> C编程杂记 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/C/Makefile.html" class="sidebar-item" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">arch <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/arch/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.html" class="sidebar-item" aria-label="CPU缓存一致性"><!--[--><!--]--> CPU缓存一致性 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/arch/risc-v.html" class="sidebar-item" aria-label="risc-v"><!--[--><!--]--> risc-v <!--[--><!--]--></a><!----></li><li><a href="/code/basic/arch/%E6%B1%87%E7%BC%96%E4%B8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html" class="sidebar-item" aria-label="汇编下的函数调用"><!--[--><!--]--> 汇编下的函数调用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">linux <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">ebpf <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/linux/ebpf/ebpf%E6%9D%82%E8%AE%B0.html" class="sidebar-item" aria-label="ebpf杂记"><!--[--><!--]--> ebpf杂记 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/code/basic/linux/kernel-user-buffer.html" class="sidebar-item" aria-label="kernel-user-buffer"><!--[--><!--]--> kernel-user-buffer <!--[--><!--]--></a><!----></li><li><a href="/code/basic/linux/page-cache.html" class="sidebar-item" aria-label="page-cache"><!--[--><!--]--> page-cache <!--[--><!--]--></a><!----></li><li><a href="/code/basic/linux/%E9%9B%B6%E6%8B%B7%E8%B4%9D.html" class="sidebar-item" aria-label="zero-cpoy"><!--[--><!--]--> zero-cpoy <!--[--><!--]--></a><!----></li><li><a href="/code/basic/linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html" class="sidebar-item" aria-label="IO多路复用"><!--[--><!--]--> IO多路复用 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/linux/kernel-bypass.html" class="sidebar-item" aria-label="kernel-bypass"><!--[--><!--]--> kernel-bypass <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">mysql <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/basic/mysql/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html" class="sidebar-item" aria-label="存储引擎"><!--[--><!--]--> 存储引擎 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/mysql/%E4%BA%8B%E5%8A%A1.html" class="sidebar-item" aria-label="事务"><!--[--><!--]--> 事务 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/mysql/%E7%B4%A2%E5%BC%95.html" class="sidebar-item" aria-label="索引"><!--[--><!--]--> 索引 <!--[--><!--]--></a><!----></li><li><a href="/code/basic/mysql/%E9%94%81.html" class="sidebar-item" aria-label="锁"><!--[--><!--]--> 锁 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">distribute <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">docker <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/distribute/docker/docker-sundry.html" class="sidebar-item" aria-label="dcoker-sundry"><!--[--><!--]--> dcoker-sundry <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">mit-6.824 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/distribute/mit-6.824/Introduction-MapReduce.html" class="sidebar-item" aria-label="Introduction-MapReduce"><!--[--><!--]--> Introduction-MapReduce <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/GFS.html" class="sidebar-item" aria-label="GFS"><!--[--><!--]--> GFS <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Backup-VMware.html" class="sidebar-item" aria-label="Backup-VMware"><!--[--><!--]--> Backup-VMware <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Zookeeper.html" class="sidebar-item" aria-label="Zookeeper"><!--[--><!--]--> Zookeeper <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/%E9%93%BE%E5%BC%8F%E5%A4%8D%E5%88%B6.html" class="sidebar-item" aria-label="链式复制"><!--[--><!--]--> 链式复制 <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Frangipani.html" class="sidebar-item" aria-label="Frangipani"><!--[--><!--]--> Frangipani <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/Spanner.html" class="sidebar-item" aria-label="Spanner"><!--[--><!--]--> Spanner <!--[--><!--]--></a><!----></li><li><a href="/code/distribute/mit-6.824/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html" class="sidebar-item" aria-label="分布式事务"><!--[--><!--]--> 分布式事务 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">front <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">angular <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/front/angular/Angular%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5.html" class="sidebar-item" aria-label="Angular环境配置和基础认知"><!--[--><!--]--> Angular环境配置和基础认知 <!--[--><!--]--></a><!----></li><li><a href="/code/front/angular/Angular%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" class="sidebar-item" aria-label="Angular基础入门"><!--[--><!--]--> Angular基础入门 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">es6 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/front/es6/ES6-01%20let%E5%92%8Cconst.html" class="sidebar-item" aria-label="ES6-01 let&amp;const"><!--[--><!--]--> ES6-01 let&amp;const <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-02%20%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html" class="sidebar-item" aria-label="ES6-02 解构赋值"><!--[--><!--]--> ES6-02 解构赋值 <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-03%20class.html" class="sidebar-item" aria-label="ES6-03 class"><!--[--><!--]--> ES6-03 class <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-04%20ES6%E6%96%B0%E5%A2%9E%E7%94%A8%E6%B3%95.html" class="sidebar-item" aria-label="ES6-04 ES6新增用法"><!--[--><!--]--> ES6-04 ES6新增用法 <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-05%20Symbol.html" class="sidebar-item" aria-label="ES6-05 Symbol"><!--[--><!--]--> ES6-05 Symbol <!--[--><!--]--></a><!----></li><li><a href="/code/front/es6/ES6-06%20Module%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA.html" class="sidebar-item" aria-label="ES6-06 Module的导入和导出"><!--[--><!--]--> ES6-06 Module的导入和导出 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">sundry <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/code/sundry/snowflakeid.html" class="sidebar-item" aria-label="snowflakeid"><!--[--><!--]--> snowflakeid <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E5%B9%82%E7%AD%89.html" class="sidebar-item" aria-label="幂等"><!--[--><!--]--> 幂等 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF.html" class="sidebar-item" aria-label="秒杀场景"><!--[--><!--]--> 秒杀场景 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E9%99%90%E6%B5%81.html" class="sidebar-item" aria-label="限流"><!--[--><!--]--> 限流 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html" class="sidebar-item" aria-label="分布式锁"><!--[--><!--]--> 分布式锁 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html" class="sidebar-item" aria-label="两阶段提交"><!--[--><!--]--> 两阶段提交 <!--[--><!--]--></a><!----></li><li><a href="/code/sundry/COW-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="sidebar-item" aria-label="COW-写时复制"><!--[--><!--]--> COW-写时复制 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">digest <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">computer-organization <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/digest/computer-organization/computer-summary.html" class="sidebar-item" aria-label="computer-summary"><!--[--><!--]--> computer-summary <!--[--><!--]--></a><!----></li><li><a href="/digest/computer-organization/system-bus.html" class="sidebar-item" aria-label="system-bus"><!--[--><!--]--> system-bus <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">csapp <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/digest/csapp/csapp-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86.html" class="sidebar-item" aria-label="csapp-信息的表示和处理"><!--[--><!--]--> csapp-信息的表示和处理 <!--[--><!--]--></a><!----></li><li><a href="/digest/csapp/csapp-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA(1).html" class="sidebar-item" aria-label="csapp-程序的机器级表示(1)"><!--[--><!--]--> csapp-程序的机器级表示(1) <!--[--><!--]--></a><!----></li><li><a href="/digest/csapp/csapp-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA(2).html" class="sidebar-item" aria-label="csapp-程序的机器级表示(2)"><!--[--><!--]--> csapp-程序的机器级表示(2) <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">network-ttd <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/digest/network-ttd/network-ttd-application.html" class="sidebar-item" aria-label="network-ttd-application"><!--[--><!--]--> network-ttd-application <!--[--><!--]--></a><!----></li><li><a href="/digest/network-ttd/network-ttd-summary.html" class="sidebar-item" aria-label="network-ttd-summary"><!--[--><!--]--> network-ttd-summary <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">ostep <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/digest/ostep/ostep-virtualization-cpu.html" class="sidebar-item" aria-label="ostep-virtualization-cpu"><!--[--><!--]--> ostep-virtualization-cpu <!--[--><!--]--></a><!----></li><li><a href="/digest/ostep/ostep-virtualization-memory.html" class="sidebar-item" aria-label="ostep-virtualization-memory"><!--[--><!--]--> ostep-virtualization-memory <!--[--><!--]--></a><!----></li><li><a href="/digest/ostep/ostep-concurrency.html" class="sidebar-item" aria-label="ostep-concurrency"><!--[--><!--]--> ostep-concurrency <!--[--><!--]--></a><!----></li><li><a href="/digest/ostep/ostep-persistence.html" class="sidebar-item" aria-label="ostep-persistence"><!--[--><!--]--> ostep-persistence <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">interview <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">pre <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview/pre/Java-%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85-%E5%AE%9E%E4%B9%A0-23-8-21.html" class="sidebar-item" aria-label="Java-喜马拉雅-实习生-23-8-21"><!--[--><!--]--> Java-喜马拉雅-实习生-23-8-21 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Java-%E6%95%B0%E6%96%B0%E7%BD%91%E7%BB%9C-%E5%AE%9E%E4%B9%A0-23-12-07.html" class="sidebar-item" aria-label="Java-数新网络-实习-23-12-07"><!--[--><!--]--> Java-数新网络-实习-23-12-07 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Golang-%E7%99%BE%E5%BA%A6-%E5%AE%9E%E4%B9%A0-23-12-11.html" class="sidebar-item" aria-label="Golang-百度-实习-23-12-11"><!--[--><!--]--> Golang-百度-实习-23-12-11 <!--[--><!--]--></a><!----></li><li><a href="/interview/pre/Golang-%E4%B8%87%E5%A3%B0%E9%9F%B3%E4%B9%90-%E5%AE%9E%E4%B9%A0-23-12-27.html" class="sidebar-item" aria-label="Golang-万声音乐-实习-23-12-27.md"><!--[--><!--]--> Golang-万声音乐-实习-23-12-27.md <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">wait <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/interview/wait/go.html" class="sidebar-item" aria-label="go面经"><!--[--><!--]--> go面经 <!--[--><!--]--></a><!----></li><li><a href="/interview/wait/java.html" class="sidebar-item" aria-label="java面经"><!--[--><!--]--> java面经 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/interview/all.html" class="sidebar-item" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">project <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">12306 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><p tabindex="0" class="sidebar-item collapsible">service <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/12306/service/%E7%94%A8%E6%88%B7%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="用户服务"><!--[--><!--]--> 用户服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="支付服务"><!--[--><!--]--> 支付服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="订单服务"><!--[--><!--]--> 订单服务 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/service/%E7%A5%A8%E5%8A%A1%E6%9C%8D%E5%8A%A1.html" class="sidebar-item" aria-label="票务服务"><!--[--><!--]--> 票务服务 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">中间件 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/12306/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis.html" class="sidebar-item" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMq.html" class="sidebar-item" aria-label="RocketMQ"><!--[--><!--]--> RocketMQ <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/project/12306/%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87.html" class="sidebar-item" aria-label="项目准备"><!--[--><!--]--> 项目准备 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="组件开发"><!--[--><!--]--> 组件开发 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1.html" class="sidebar-item" aria-label="数据库表设计"><!--[--><!--]--> 数据库表设计 <!--[--><!--]--></a><!----></li><li><a href="/project/12306/%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="测试"><!--[--><!--]--> 测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">snmp-压力测试 <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/snmp-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/snmp-Java.html" class="sidebar-item" aria-label="snmp-Java"><!--[--><!--]--> snmp-Java <!--[--><!--]--></a><!----></li><li><a href="/project/snmp-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/snmp%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95.html" class="sidebar-item" aria-label="snmp压力测试"><!--[--><!--]--> snmp压力测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">summer-framework <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/summer-framework/IOC.html" class="sidebar-item" aria-label="IOC"><!--[--><!--]--> IOC <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/AOP.html" class="sidebar-item" aria-label="AOP"><!--[--><!--]--> AOP <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/JdbcTemplate-Transaction.html" class="sidebar-item" aria-label="JdbcTemplate-Transaction"><!--[--><!--]--> JdbcTemplate-Transaction <!--[--><!--]--></a><!----></li><li><a href="/project/summer-framework/MVC.html" class="sidebar-item" aria-label="MVC"><!--[--><!--]--> MVC <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item collapsible">ysyx <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/ysyx/verilog.html" class="sidebar-item" aria-label="verilog"><!--[--><!--]--> verilog <!--[--><!--]--></a><!----></li><li><a href="/project/ysyx/%E5%85%B3%E4%BA%8E%E6%8F%90%E9%97%AE.html" class="sidebar-item" aria-label="关于提问"><!--[--><!--]--> 关于提问 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">template <span class="right arrow"></span></p><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/template/markdown.html" class="sidebar-item" aria-label="markdown的使用"><!--[--><!--]--> markdown的使用 <!--[--><!--]--></a><!----></li><li><a href="/template/mermaid%E4%BD%BF%E7%94%A8.html" class="sidebar-item" aria-label="mermaid使用"><!--[--><!--]--> mermaid使用 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/About.html" class="sidebar-item sidebar-heading" aria-label="关于"><!--[--><!--]--> 关于 <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p>有关图的算法，包括最短路，最小生成树，二分图</p><!-- more --><p><img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/e47ce8d5e2a4321c42eeb251da54e3b9.png" alt="最短路.drawio.png" loading="lazy"></p><h1 id="最短路" tabindex="-1"><a class="header-anchor" href="#最短路" aria-hidden="true">#</a> 最短路</h1><h2 id="_1-单源最短路" tabindex="-1"><a class="header-anchor" href="#_1-单源最短路" aria-hidden="true">#</a> 1. 单源最短路</h2><h3 id="_1-1-dijkstra算法" tabindex="-1"><a class="header-anchor" href="#_1-1-dijkstra算法" aria-hidden="true">#</a> 1.1 Dijkstra算法</h3><p>对于没有负权边的单源最短路问题，通常使用Dijkstra算法解决，其中当图是稀疏图时，考虑使用堆优化版的Dijkstra算法，稠密图使用朴素版的Dijkstra算法</p><h4 id="_1-1-1-朴素版的dijkstra算法" tabindex="-1"><a class="header-anchor" href="#_1-1-1-朴素版的dijkstra算法" aria-hidden="true">#</a> 1.1.1 朴素版的Dijkstra算法</h4><ol><li>初始化起点为0，其他点为正无穷，定义<code>s数组</code>为已经确定最短路的点</li><li>循环n次，每次选取不在集合<code>s</code>中，距离起点最近的点<code>t</code>，加入集合<code>s</code>中，更新其他点的最短路径</li></ol><p>常用模板：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt; (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
const int N = 1e3 + 10;
int n, m;
int g[N][N], dist[N];
bool st[N];

int Dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    // 初始化第一个点的距离为0
    dist[1] = 0;
    
    rep(i,1,n + 1)
    {
        // st[]中为true的点的集合，就是已经确定最短距离的集合s
        // 借助t从而选取不在s中，且距离最小的一个点加入s中
        // 注意这里是以假设图中没有负权边为前提
        int t = -1;
        rep(j,1,n + 1)
            if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;
        
        // 将该点加入s中
        st[t] = true;
        
        if(t == n) break;
        
        // 更新其他点的最短路径
        rep(j,1,n + 1)
            dist[j] = min(dist[t] + g[t][j], dist[j]);
        
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    memset(g,0x3f,sizeof g);
    cin &gt;&gt; n &gt;&gt; m;
    
    rep(i,1,m + 1)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        // 处理重边
        g[a][b] = min(g[a][b], c);
    }
    
    cout &lt;&lt; Dijkstra();
    
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-1-2-堆优化的dijkstra算法" tabindex="-1"><a class="header-anchor" href="#_1-1-2-堆优化的dijkstra算法" aria-hidden="true">#</a> 1.1.2 堆优化的Dijkstra算法</h4><ol><li><p>朴素版中最耗时的操作是以下两步</p><ol><li>在未确定最短距离的集合中寻找最小值</li><li>用新选出的点更新其他的边</li></ol></li><li><p>无论图是稠密图还是稀疏图，都要遍历n边，但是可以考虑一下稀疏图，他的出边实际上并没有n那么多，所以首先可以考虑使用邻接表来存储，这样遍历更新的次数会减少</p></li><li><p>对于寻找最小值，可以考虑使用优先队列来进行维护寻找</p></li></ol><p>由于对于一个点，队列不支持原地修改，所以可能在队列中存在多个边，所以要使用st数组维护状态</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt; (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 1e6 + 10;
int n, m;
int e[N], ne[N], w[N], h[N], dist[N], idx;
bool st[N];


void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; 
}

int Dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    // 初始化第一个点的距离为0
    dist[1] = 0;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;
    
    heap.push({0,1});
    
    
    while(heap.size())
    {
        auto t = heap.top();
        int dis = t.first , ver = t.second;
        heap.pop();
        if(st[ver]) continue;
        st[ver] = true;
        
        for(int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if(dist[j] &gt; dis + w[i])
            {
                dist[j] = dis + w[i];
                heap.push({dist[j],j});
            }
            
        }
    }
    
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    memset(h,-1,sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    
    rep(i,1,m + 1)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a,b,c);
    }
    
    cout &lt;&lt; Dijkstra();
    
    return 0;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-bellman-ford算法" tabindex="-1"><a class="header-anchor" href="#_1-2-bellman-ford算法" aria-hidden="true">#</a> 1.2 Bellman-Ford算法</h3><p>当存在负权边时，不能使用Dijsktra算法，选择采用Bellman-Ford算法。</p><p>这个算法的思想是：循环n遍，循环内部遍历m条边（a,b,w），计算<code>dist[b] = min(dist[b],dist[a] + w)</code>。其中n的含义是，最多经过n条边选取的最短路径。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 1e4;
const int M = 1e5 + 10;
int n, m, k, idx;
int dist[N],backup[N];
int e[N], ne[N], h[N], w[N];

int add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

void bf()
{
    memset(dist, 0x3f, sizeof dist);
 
    dist[1] = 0;
    
    rep(i, 1, k)
    {
        memcpy(backup, dist, sizeof dist);
        rep(i, 1, n)
        {
            for(int j = h[i]; j != -1; j = ne[j])
            {
                int t = e[j];
                //  注意使用备份数组防止串联修改
                dist[t] = min(dist[t], backup[i] + w[j]);
            }
        }
    }
}

int main()
{
    memset(h, -1, sizeof h);
    
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    
    rep(i, 1, m)
    {
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        add(x,y,z);
    }
    bf();
    if (dist[n] &gt; 0x3f3f3f3f / 2) cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; dist[n];
    
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>backup数组的含义： <img src="http://blog-zzys.oss-cn-beijing.aliyuncs.com/articles/7d063fa16dad706139cb69d617a9e409.png" alt="backup.png" loading="lazy"></p><ul><li><p>如果不使用backup：在第一次遍历，也是唯一一次遍历时：原本b的距离是正无穷，c的距离也是正无穷，在遍历所有边时，先将b更新为1，再更新c时，就会将b更新为2，但这很显然超出了预期。</p></li><li><p>如果使用backup，每一次更新都使用backup的数据，虽然先将b更新为1，但是backup中b的距离依然是正无穷，这样就符合我们的预期。</p></li></ul><p>对于这个判断条件<code>dist[n] &gt; 0x3f3f3f3f / 2</code>，是因为对于n和n-1两个点，如果起点无法到达，那么它们两个的dist就是正无穷，但是一旦这两个之间的距离为负数，就有可能将n的dist更新的比0x3f3f3f3f要小，所以就去一个保险值。</p><h3 id="_1-3-spfa算法" tabindex="-1"><a class="header-anchor" href="#_1-3-spfa算法" aria-hidden="true">#</a> 1.3 SPFA算法</h3><p>SPFA是bellman-frod算法的改进版，可以发现，<code>dist[t] = min(dist[t], backup[i] + w[j]);</code>这一步并不是每一次都真的进行更新操作，只有在i点的距离发生变小后，才会更新t的距离。</p><p>所以可以采用宽搜的思想，当我们将一个点的距离更新后，就将其放入队列中，更新它的所有出边。当队列为空时，也就没有可以更新的点了。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 1e5 + 10;
int e[N], ne[N], h[N], w[N];
int n, m, idx;
int dist[N];
bool st[N];
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void spfa()
{
    memset(dist,0x3f,sizeof dist);
    
    dist[1] = 0;
    
    queue&lt;int&gt; q;
    q.push(1);
    st[1] = true;
    while(q.size())
    {
        int t = q.front();
        st[t] = false;
        q.pop();
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] &gt; dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
}

int main()
{
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    
    rep(i, 1, m)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    }
    
    spfa();
    if(dist[n] == 0x3f3f3f3f) cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; dist[n];
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以利用SPFA来求图中是否存在负环：每当一条边更新一遍时，它所经历的边数就是更新它的点的边数加一，如果这个数字大于等于点数，那么就存在一个环，由于此算法是求最短路，所以该环就是负环。</p><p>注意负环有可能从起点无法到达，所以将所有点都放入SPFA中进行计算</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;//spfa求负环 
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt; PII;
const int N=1e6;
int n,m;
int d[N],h[N],e[N],ne[N],w[N],idx,cnt[N];
bool st[N];

void add(int a,int b,int c)
{
    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}

bool spfa()
{
    queue&lt;int&gt; a;
    for(int i=1;i&lt;=n;i++)//将所有点入队
    {
        a.push(i);
        st[i]=true;
    }
    while(a.size())
    {
        int t=a.front();
        a.pop();
        st[t]=false;
        
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(d[j]&gt;d[t]+w[i])
            {
                d[j]=d[t]+w[i];
                cnt[j]=cnt[t]+1;//每次成功更新，都让其经过的边数等于与上一个点加一，
                if(cnt[j]&gt;=n) return true;//如果说经过的变数大于总点数 ，那么一定有重复点，也就是存在环
                if(!st[j])
                {
                    st[j]=true;
                    a.push(j);
                }
            }
        }
    };
    return false
}

int main(){
    ios::sync_with_stdio(false);
    cin&gt;&gt;n&gt;&gt;m;
    memset(h,-1,sizeof h);
    for(int i=0;i&lt;m;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        add(a,b,c);
    }
    if(spfa()) cout&lt;&lt;&quot;Yes&quot;;
    else cout&lt;&lt;&quot;No&quot;;
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-多源最短路" tabindex="-1"><a class="header-anchor" href="#_2-多源最短路" aria-hidden="true">#</a> 2. 多源最短路</h2><h3 id="_2-1-floyd算法" tabindex="-1"><a class="header-anchor" href="#_2-1-floyd算法" aria-hidden="true">#</a> 2.1 Floyd算法</h3><p>Floyd基于动态规划，用于求解多源最短路</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
const int N=3e2;
const int INF = 1e9;
int n, m, k;
int g[N][N];


void floyd()
{
    rep(k, 1, n)
        rep(i, 1, n)
            rep(j, 1, n)
                g[i][j] = min(g[i][j] , g[i][k] + g[k][j]);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    
    rep(i,1,n)
    {
        rep(j, 1, n)
        {
            if (i == j) g[i][j] = 0;
            else g[i][j] = INF;
        }
    }
    rep(i, 1, m)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = min(g[a][b], c);
    }
    floyd();
    
    while(k --)
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        if (g[a][b] &gt; INF / 2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;
        else cout &lt;&lt; g[a][b] &lt;&lt; endl;
    }
    
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树" aria-hidden="true">#</a> 最小生成树</h1><p>一般来说稠密图使用朴素版的prim算法，稀疏图堆优化版的prim算法和Kruskal算法都可以用，由于Kruskal较短，所以优先使用Kruskal。</p><h2 id="_1-prim-算法" tabindex="-1"><a class="header-anchor" href="#_1-prim-算法" aria-hidden="true">#</a> 1. prim 算法</h2><h3 id="_1-1-1-朴素版prim算法" tabindex="-1"><a class="header-anchor" href="#_1-1-1-朴素版prim算法" aria-hidden="true">#</a> 1.1.1 朴素版prim算法</h3><p>时间复杂度：O(n^2)</p><p>和Dijkstra思路相似，只不过dist数组维护的是点到集合的最短距离</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 510;
const int INF = 0x3f3f3f3f;
int n, m;
int g[N][N],dist[N];
bool st[N];

int prim()
{
    int ans = 0;
    memset(dist,INF,sizeof dist);
    dist[1] = 0;
    rep(i, 1, n)
    {
        int t = -1;
        rep(j, 1, n)
            if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j;
            
        if (dist[t] == INF) return INF;
        ans += dist[t];
        st[t] = true;
        
        rep(j,1,n)
            dist[j] = min(dist[j] ,g[t][j]);
    }
    return ans;
}


int main()
{
    memset(g,INF,sizeof g);
    cin &gt;&gt; n &gt;&gt; m;
    while (m -- )
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    int t = prim();
    if (t == INF) cout &lt;&lt;&quot;impossible&quot; &lt;&lt; endl;
    else cout &lt;&lt; t &lt;&lt; endl;
    
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-2-堆优化版prim算法" tabindex="-1"><a class="header-anchor" href="#_1-1-2-堆优化版prim算法" aria-hidden="true">#</a> 1.1.2 堆优化版prim算法</h3><p>时间复杂度：O(mlogn)</p><h2 id="_2-kruskal-算法" tabindex="-1"><a class="header-anchor" href="#_2-kruskal-算法" aria-hidden="true">#</a> 2. Kruskal 算法</h2><p>时间复杂度：O(mlogm)</p><ol><li>将所有边按权重从小到大排序（快速排序）</li><li>枚举每条边a，b 权重c。如果a，b不连通，将这条边加入集合中（并查集维护）</li></ol><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int M = 2e5 + 10;
int n, m;
int p[M];
struct Edge
{
    int a, b, w;
}edge[M];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
bool cmp(Edge a, Edge b)
{
    return a.w &lt; b.w;
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    rep(i, 1, n) p[i] = i;
    rep(i, 1, m)
    {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        edge[i] = {a, b, c};
    }
    
    sort(edge + 1, edge + m + 1, cmp);
    int res = 0, cnt = 0;
    
    rep(i, 1, m)
    {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        a = find(a), b = find(b);
        if(a != b)
        {
            p[a] = b;
            res += w;
            cnt ++;
        }
    }
    if (cnt &lt; n - 1) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;
    else cout &lt;&lt; res;
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="二分图" tabindex="-1"><a class="header-anchor" href="#二分图" aria-hidden="true">#</a> 二分图</h1><p>一个图是二分图当且仅当图中不含奇数环（边数）</p><h2 id="_1-染色法" tabindex="-1"><a class="header-anchor" href="#_1-染色法" aria-hidden="true">#</a> 1. 染色法</h2><p>时间复杂度：O(n+m)</p><p>染色法用来判断一个图是否是二分图，从起点开始，将起点染成1，然后把所有相邻的点染成2，依次类推，如果发现有相邻的点颜色相同，那么就说明存在奇数环，不是二分图。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 2e5 + 10;
int n, m;
int e[N], ne[N], h[N], idx;
int c[N];
void add(int a, int b)
{
    e[idx] = b,  ne[idx] = h[a] , h[a] = idx ++;
}


bool dfs(int u, int color)
{
    c[u] = color;
    
    for(int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        
        if(!c[j])
        {
            if(!dfs(j,3 - color)) return false;
        }
        else if(c[j] == color) return false;
    }
    return true;
}

int main()
{
    memset(h, -1, sizeof h);
    cin &gt;&gt; n &gt;&gt; m;
    rep(i, 1, m)
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
        add(b, a);
    }
    bool f = true;
    rep(i, 1, n)
    {
        if (!c[i])
        {
            if (!dfs(i,1))
            {
                f = false;
                break;
            }
        }
    }
    if (!f) cout &lt;&lt; &quot;No&quot;;
    else cout &lt;&lt; &quot;Yes&quot;;
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-匈牙利算法" tabindex="-1"><a class="header-anchor" href="#_2-匈牙利算法" aria-hidden="true">#</a> 2. 匈牙利算法</h2><p>时间复杂度：O(mn)，但实际运行时间远小于O(mn)</p><p>使用匈牙利算法来求一个给定的二分图的最大匹配值。</p><p>对于给定的一个二分图，将左半边称为男孩团体，右半边乘坐女孩团体，解题目的就是能最大数量组成情侣。其中如果两个异性存在一条边，则看作有好感度，可以尝试组成情侣，否则不予考虑。</p><p>遍历男生团体，对于其中一个男生，我们遍历所有和他有好感度的女生：</p><ol><li>当前女生还未匹配，则组成情侣</li><li>当前女生已经匹配，但是和她匹配的男生还可以找到新的女生（递归进行1，2）</li><li>遍历过了所有女生都无法匹配，则放弃</li></ol><p>在代码中math数组用来维护男女的匹配情况。st数组用来维护在每一个男生寻找匹配时，女生被匹配的状态，保证递归寻找不要去寻找重复的匹配，否则会陷入死循环</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;bits/stdc++.h&gt;
#define rep(i,l,r) for (int i = (l); i &lt;= (r); ++ i)
#define per(i,r,l) for (int i = (r); i &gt; (l); -- i)
typedef long long LL;

using namespace  std;
typedef pair&lt;int,int&gt; PII;
const int N = 5e2 + 10;
const int M = 1e5 + 10;
int e[M], ne[M], h[N], idx;
int n1, n2, m;
bool st[N];
int math[N];

void add(int a, int b)
{
    e[idx] = b,  ne[idx] = h[a] , h[a] = idx ++;
}

bool find(int u)
{
    for(int i = h[u] ; i != -1; i = ne[i])
    {
        int j = e[i];
        
        if (!st[j])
        {
            st[j] = true;
            if (math[j] == 0 || find(math[j]))
            {
                math[j] = u;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    memset(h, -1, sizeof h);

    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;
    
    while (m -- )
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    }
    int res = 0;
    rep(i,1,n1)
    {
        memset(st,false,sizeof st);
        if(find(i)) res ++;
    }
    cout &lt;&lt; res;
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 2803436425@qq.com">YangZhang</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/code/algorithm/%E6%A0%91%E5%9B%BE/%E6%A0%91%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E9%81%8D%E5%8E%86.html" class="" aria-label="树和图的存储及遍历"><!--[--><!--]--> 树和图的存储及遍历 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-8f4b6e6f.js" defer></script>
  </body>
</html>
