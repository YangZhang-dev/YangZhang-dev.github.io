---
title: 泛型

order: 1
author: zzys
date: 2023-09-17
category:
- 面经
tags:
- 泛型
- 函数式
---

[Java的＜? super T＞和＜? extends R＞理解与应用-CSDN博客](https://blog.csdn.net/zhangbeizhen18/article/details/126457554)

src/main/java/org/opengoofy/index12306/biz/orderservice/service/impl/OrderServiceImpl.java#111

泛型擦除：[Java泛型中的类型擦除详解 ](https://zhuanlan.zhihu.com/p/346486993)，[泛型概述(下)](https://www.yuque.com/bravo1988/java/ro0gh5)

## 泛型

在阅读ArrayList时可以发现，ArrayList底层存储数据的容器仍然是Object数组，这使我不禁会想，既然底层是Object数组，那么泛型在这里起到了什么作用呢？

### 术语

`ArrayList<T>`：T被称为**类型参数**，整体称为**泛型类型**。

`ArrayList<String>`：String称为**实际参数**，整体称为**参数化的类型**（ParameterizedType）。

### 泛型擦除

不同于C#的**具现化式泛型**（Reified Generics），Java的泛型的实现方式叫作**类型擦除式泛型**（Type Erasure Generics），简单粗暴地直接在编译时把`ArrayList<Integer>`还原回`ArrayList`，只在元素访问、修改时自动插入一些强制类型转换和检查指令。

编译之前：

```java
public static void main(String[] args) {
    Map<String, String> map = new HashMap<String, String>();
    map.put("hello", "你好");
    map.put("how are you?", "吃了没？");
    System.out.println(map.get("hello"));
    System.out.println(map.get("how are you?"));
}
```

生成字节码文件后反编译：

```java
public static void main(String[] args) {
    Map map = new HashMap();
    map.put("hello", "你好");
    map.put("how are you?", "吃了没？");
    System.out.println((String) map.get("hello"));
    System.out.println((String) map.get("how are you?"));
}
```

由此可以看出，泛型本身是一种编译时的机制，是**Java程序员和编译器之间的协议**。

- 泛型是JDK专门为**编译器**创造的语法糖，只在编译期，由编译器负责解析，**虚拟机不知情**
- 存入：普通类继承泛型类并给变量类型T赋值后，就能强制让**编译器**帮忙进行类型校验
- 取出：代码编译时，**编译器**底层会根据实际类型参数自动进行类型转换，无需程序员在外部手动强转
- 实际上，编译后的Class文件还是JDK1.5以前的样子，虚拟机看到的仍然是Object

为什么泛型不可以使用**基本类型**呢？因为本身泛型的引入就是为了解决**引用类型**强转易出错的问题，归根结底，Java泛型之所以无法支持基本类型，还是因为存在泛型擦除，底层仍是Object，而基本类型无法直接赋值给Object类型，导致JDK只能用自动拆装箱特性来弥补，**而自动拆装箱会带来性能损耗。**

### 验证泛型擦除

```java
public class GenericTypes {
    public static void method(List<String> list) {
        System.out.println("invoke method(List<String> list)");
    }
    public static void method(List<Integer> list) {
        System.out.println("invoke method(List<Integer> list)");
    }
}
```

以上代码无法通过编译，idea报错为：`method(List<String>)` 与 `method(List<Integer>)`冲突；两个方法具有相同的擦除。

```java
class V{
    public static void main(String[] args) {
        ArrayList<String> stringArrayList = new ArrayList<>();
        ArrayList<Integer> integerArrayList = new ArrayList<>();
        if (stringArrayList.getClass() == integerArrayList.getClass()){
            System.out.println("泛型擦除");
        }
    }
}
// 泛型擦除
```

在运行时获取两个ArrayList的Class对象会发现，它们两个实际上是同一个CLass